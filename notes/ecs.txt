Using this code as a starting point: https://devlog.hexops.com/2022/lets-build-ecs-part-2-databases/

Refactor
  - Types struct, maps type names to type ids.
  - Archetypes gain a list of shared_ids, column_keys, columns is just an ArrayList(Column)
  - shared_ids and column_keys are sorted asc at Archetype creation, assumed sorted from then on
  - Archetypes fn to return: EntityPayload -> .{id: EntityID, components: HashMapUnmanaged(TypeID, *[]u8), shared: ArrayList(SharedID)}
  - Remove AnyColumn, just use Column, data is just an ArrayList(u8), CRUD ops are bytes only? casting happens in Archetypes.
  - Entity Queries, used for iteration, entity testing. 
    .has() .none() .has_shared() .none_shared() .where(callback) .test(entity) .testAll(entities) .run() .iterator() .toList()
  - deleted EntityID are saved in Entities, ideally as an ArrayList(EntityIDRange{.low: u32, .high: u32}), to encapsulate large spans of deleted IDs (single values are both low and high?)
  - Prefabs + Variances
  - serialization: human-readable (debugging, sharing cross platform) and binary (local and fast)
  - parallel / thread-safe?